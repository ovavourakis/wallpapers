
<!DOCTYPE html>
  <head>
    <meta charset="utf-8">
    <title>Polar Clock</title>
    <style>
      *,
      *:before,
      *:after {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
      }

      body {
        background: var(--bg-color);
        font-family: 'Courier New';
        font-weight: 600;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        margin: auto;
        position: relative;
        overflow: hidden;
        -webkit-user-select: none;
        -webkit-font-smoothing: antialiased;
        text-rendering: optimizeLegibility;
      }

    #human-time {
      color: var(--text-color);
      font-size: 0.8em;
      text-align: right;
      position: absolute;
      bottom: 2em;
      right: 2em;
    }

    #day-of-week {
      display: block;
    }

    </style>
  </head>
  <body style="background: var(--bg-color) !important;">
    <div id="human-time">
      <span id="day-of-week"></span><span id="date"></span>
      <div>
        <span id="hours-minutes-seconds"></div>
      </div>
    </div>
    <script>
      // ============================================
      // COLOR CONFIGURATION - Modify colors here
      // ============================================
      var COLORS = {
        background: '#000000',        // Main background color
        text: '#444',                  // Text color for time display
        hourRing: '#920000',          // Color for the hour ring (red)
        otherRings: '#fffff8',        // Color for other rings (off-white)
        secondsIndicator: '#fffff8',  // Color for the seconds indicator
        secondArc: '#920000',         // Color for the second arc (around seconds indicator)
        colorScaleStart: 'hsl(-360,90%,65%)',  // Start of color scale (unused)
        colorScaleEnd: 'hsl(360,90%,65%)'      // End of color scale (unused)
      };
      
      // ============================================
      // FEATURE TOGGLES - Enable/disable features
      // ============================================
      var SHOW_SECONDS = true;  // Set to false to hide the seconds indicator
      var SECONDS_OPACITY = 100;  // Opacity of the seconds indicator in percent (0-100)
      var SECONDS_FILL_EMPTY_MODE = false;  // Set to true for fill-empty mode (alternating fill/empty pattern)
      var SECONDS_ROTATING_MODE = true;  // Set to true for rotating arc, false for filling arc
      var SECONDS_ARC_LENGTH = 2 * Math.PI * 5/100;  // fixed arc length in radians 
      var VARY_LENGTH = false;  // alternatively vary arc length over course of minute
      
      // Outer ring (second arc) configuration - independent from seconds indicator
      var SHOW_SECOND_ARC = true;  // Set to false to hide the outer ring
      var SECOND_ARC_OPACITY = 100;  // Opacity of the outer ring in percent (0-100)
      var SECOND_ARC_FILL_EMPTY_MODE = false;  // Set to true for fill-empty mode (alternating fill/empty pattern)
      var SECOND_ARC_ROTATING_MODE = true;  // Set to true for rotating arc, false for filling arc
      var SECOND_ARC_LENGTH = 2 * Math.PI * 5/100;  // fixed arc length in radians
      var VARY_SECOND_ARC_LENGTH = true;  // alternatively vary arc length over course of minute
      
      
      // Set CSS variables for use in stylesheet
      document.documentElement.style.setProperty('--bg-color', COLORS.background);
      document.documentElement.style.setProperty('--text-color', COLORS.text);
      
      // Force dark blue background immediately
      document.body.style.backgroundColor = COLORS.background;
      document.documentElement.style.backgroundColor = COLORS.background;
    </script>
    <script src="d3.js"></script>
    <script src="moment.js"></script>
    <script>
        (function() {
        // Ensure dark blue background
        document.body.style.backgroundColor = COLORS.background;
        
        // Wait for d3 to be available
        function init() {
          if (typeof d3 === 'undefined') {
            setTimeout(init, 50);
            return;
          }
        
        // Avoid shortest-path interpolation.
        function interpolateHsl(a, b) {
          var i = d3.interpolateString(a, b);
          return function(t) {
            return d3.hsl(i(t));
          };
        }

        var width = window.innerWidth || 1920;
        var height = window.innerHeight || 1080;
        var cornerRadius = 5;

        var radius = Math.min(width, height) / 2.2;
        var spacing = 0.09;
        var secondsSpacing = 0.02; // Much thinner spacing for seconds arc

        var formatMinute = d3.time.format("%M m"),
            formatHour = d3.time.format("%H h"),
            formatDay = d3.time.format("%a"),
            formatDate = d3.time.format("%d d"),
            formatMonth = d3.time.format("%b"),
            formatSecond = d3.time.format("%S s");

        var color = d3.scale.linear()
            .range([COLORS.colorScaleStart, COLORS.colorScaleEnd])
            .interpolate(interpolateHsl);

        var arc = d3.svg.arc()
            .startAngle(function(d) { 
              // Rotating mode for seconds: fixed-length arc that rotates
              // Right edge (endAngle) is at zero degrees when seconds are at XX:00
              if (d.index === 0.6 && SHOW_SECONDS && SECONDS_ROTATING_MODE) {
                var endAngle = d.value * 2 * Math.PI;
                // Calculate arc length: use dynamic length if VARY_LENGTH is enabled
                var arcLength;
                if (VARY_LENGTH) {
                  // ARC_LENGTH = π*0.25*sin((2π)/60 * x + 30) + 0.251π
                  // where x is the current seconds
                  var x = d.value * 60; // Convert d.value (seconds/60) to seconds
                  arcLength = Math.PI * 0.25 * Math.sin((2 * Math.PI) / 60 * x + 30) + 0.27 * Math.PI;
                } else {
                  arcLength = SECONDS_ARC_LENGTH;
                }
                return endAngle - arcLength;
              }
              // Rotating mode for second arc (0.65): opposite direction with -π/2 offset
              if (d.index === 0.65 && SHOW_SECOND_ARC && SECOND_ARC_ROTATING_MODE) {
                var endAngle = (1 - d.value) * 2 * Math.PI - Math.PI / 2;
                // Calculate arc length: use dynamic length if VARY_SECOND_ARC_LENGTH is enabled
                var arcLength;
                if (VARY_SECOND_ARC_LENGTH) {
                  var x = d.value * 60; // Convert d.value (seconds/60) to seconds
                  arcLength = 1/5 * Math.PI * Math.sin((2 * Math.PI) / 60 * x + 30) + 2/5 * Math.PI;
                } else {
                  arcLength = SECOND_ARC_LENGTH;
                }
                return endAngle - arcLength;
              }
              // Fill-empty mode: check if even or odd minute
              if (d.index === 0.6 && SHOW_SECONDS && SECONDS_FILL_EMPTY_MODE) {
                // Even minute: start from 0 (growing clockwise)
                if (d.isEvenMinute !== false) {
                  return 0;
                }
                // Odd minute: shrinking clockwise
                // Value goes from 1.0 to 0.0 (remaining portion)
                // startAngle moves clockwise: at value=1.0 (full), startAngle=0; at value=0.0 (empty), startAngle=2π
                // So startAngle = (1 - value) * 2π
                var startAngle = (1 - d.value) * 2 * Math.PI;
                // Handle edge case: when value is 0, set both angles to 2π to draw nothing
                if (d.value <= 0.001) {
                  return 2 * Math.PI;
                }
                return startAngle;
              }
              // Fill-empty mode for second arc (0.65): opposite direction with -π/2 offset
              if (d.index === 0.65 && SHOW_SECOND_ARC && SECOND_ARC_FILL_EMPTY_MODE) {
                // Even minute: start from 2π - π/2 (growing counter-clockwise from offset)
                if (d.isEvenMinute !== false) {
                  return 2 * Math.PI - Math.PI / 2;
                }
                // Odd minute: shrinking counter-clockwise
                // Value goes from 1.0 to 0.0 (remaining portion)
                // For opposite direction: startAngle = value * 2π - π/2
                var startAngle = d.value * 2 * Math.PI - Math.PI / 2;
                // Handle edge case: when value is 0, set both angles to avoid drawing
                if (d.value <= 0.001) {
                  return 2 * Math.PI - Math.PI / 2;
                }
                return startAngle;
              }
              // Default: start from 0 (filling arc)
              return 0;
            })
            .endAngle(function(d) { 
              // Rotating mode for seconds: fixed-length arc that rotates
              // Right edge (endAngle) is at zero degrees when seconds are at XX:00
              if (d.index === 0.6 && SHOW_SECONDS && SECONDS_ROTATING_MODE) {
                return d.value * 2 * Math.PI;
              }
              // Rotating mode for second arc (0.65): opposite direction with -π/2 offset
              if (d.index === 0.65 && SHOW_SECOND_ARC && SECOND_ARC_ROTATING_MODE) {
                return (1 - d.value) * 2 * Math.PI - Math.PI / 2;
              }
              // Fill-empty mode: check if even or odd minute
              if (d.index === 0.6 && SHOW_SECONDS && SECONDS_FILL_EMPTY_MODE) {
                // Even minute: end at current value (growing clockwise)
                if (d.isEvenMinute !== false) {
                  return d.value * 2 * Math.PI;
                }
                // Odd minute: end at 2π (full circle, shrinking clockwise)
                // Handle edge case: when value is 0, set both angles to 2π to draw nothing
                if (d.value <= 0.001) {
                  return 2 * Math.PI;
                }
                return 2 * Math.PI;
              }
              // Fill-empty mode for second arc (0.65): opposite direction with -π/2 offset
              if (d.index === 0.65 && SHOW_SECOND_ARC && SECOND_ARC_FILL_EMPTY_MODE) {
                // Even minute: end at (1 - value) * 2π - π/2 (growing counter-clockwise)
                if (d.isEvenMinute !== false) {
                  return (1 - d.value) * 2 * Math.PI - Math.PI / 2;
                }
                // Odd minute: end at -π/2 (full circle, shrinking counter-clockwise)
                // Handle edge case: when value is 0, set both angles to avoid drawing
                if (d.value <= 0.001) {
                  return -Math.PI / 2;
                }
                return -Math.PI / 2;
              }
              // Default: fill up to value (filling arc)
              return d.value * 2 * Math.PI; 
            })
            .innerRadius(function(d) { 
              // Second arc (0.65) starts after seconds indicator with same gap as between other rings
              // Gap between other rings: next_ring_inner - previous_ring_outer = 0.5 - 0.49 = 0.01
              if (d.index === 0.65) return (0.6 + secondsSpacing + 0.01) * radius;
              return d.index * radius; 
            })
            .outerRadius(function(d) { 
              // Use thinner spacing for seconds (index 0.6)
              if (d.index === 0.6) return (d.index + secondsSpacing) * radius;
              // Second arc (0.65) has same width as seconds indicator (secondsSpacing)
              if (d.index === 0.65) return (0.6 + secondsSpacing + 0.01 + secondsSpacing) * radius;
              return (d.index + spacing) * radius;
            })
            .cornerRadius(cornerRadius);

        function fields() {
          var now = new Date;
          // Include milliseconds for smooth continuous seconds movement (if either arc is shown)
          var seconds = (SHOW_SECONDS || SHOW_SECOND_ARC) ? (now.getSeconds() + now.getMilliseconds() / 1000) : now.getSeconds();
          var minutes = now.getMinutes() + seconds / 60;
          var hours = now.getHours() + minutes / 60;
          // Day of week: continuous from Monday 00:00 (0) to Sunday 23:59:59 (1.0)
          // Shift so Monday (getDay()=1) becomes 0, Sunday (getDay()=0) becomes 6
          var dayOfWeekValue = ((now.getDay() + 6) % 7 + hours / 24) / 7;
          // Month: continuous from January 1st 00:00 (0) to December 31st 23:59:59 (1.0)
          var daysInMonth = 32 - new Date(now.getYear(), now.getMonth(), 32).getDate();
          var monthValue = (now.getMonth() + (now.getDate() - 1 + hours / 24) / daysInMonth) / 12;
          // Day of month: continuous from 1st at 00:00 (0) to last day at 23:59:59 (1.0)
          var dateValue = (now.getDate() - 1 + hours / 24) / daysInMonth;
          
          var fieldsArray = [
            {index: .5, text: formatMinute(now), value: minutes / 60},
            {index: .4, text: formatHour(now),   value: hours / 24},
            {index: .3, text: formatDay(now),    value: dayOfWeekValue},
            {index: .2, text: formatDate(now),   value: dateValue},
            {index: .1, text: formatMonth(now),  value: monthValue}
          ];
          
          // Add seconds indicator if enabled
          if (SHOW_SECONDS) {
            if (SECONDS_FILL_EMPTY_MODE) {
              // In fill-empty mode, determine if we're in an even or odd minute
              var currentMinute = now.getMinutes();
              var isEvenMinute = (currentMinute % 2) === 0;
              
              if (isEvenMinute) {
                // Even minute: fill with seconds color from 0 to current seconds (growing clockwise)
                fieldsArray.unshift({index: .6, text: formatSecond(now), value: seconds / 60, fillEmptyMode: true, isEvenMinute: true});
              } else {
                // Odd minute: start with full arc and shrink it clockwise
                // Value represents how much is remaining: 1.0 = full, 0.0 = empty
                // We store (1 - seconds/60) so it shrinks from 1.0 to 0.0
                fieldsArray.unshift({index: .6, text: formatSecond(now), value: 1.0 - seconds / 60, fillEmptyMode: true, isEvenMinute: false});
              }
            } else {
              fieldsArray.unshift({index: .6, text: formatSecond(now), value: seconds / 60}); // Seconds - thin arc (continuous)
            }
          }
          
          // Add second arc (outer ring) if enabled - independent from seconds indicator
          if (SHOW_SECOND_ARC) {
            if (SECOND_ARC_FILL_EMPTY_MODE) {
              // In fill-empty mode, determine if we're in an even or odd minute
              var currentMinute = now.getMinutes();
              var isEvenMinute = (currentMinute % 2) === 0;
              
              if (isEvenMinute) {
                // Even minute: opposite direction (growing counter-clockwise)
                fieldsArray.unshift({index: .65, text: formatSecond(now), value: seconds / 60, fillEmptyMode: true, isEvenMinute: true});
              } else {
                // Odd minute: opposite direction (shrinking counter-clockwise)
                fieldsArray.unshift({index: .65, text: formatSecond(now), value: 1.0 - seconds / 60, fillEmptyMode: true, isEvenMinute: false});
              }
            } else {
              // Second arc: opposite direction with same value
              fieldsArray.unshift({index: .65, text: formatSecond(now), value: seconds / 60});
            }
          }
          
          return fieldsArray;
        }

        var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

        var field = svg.selectAll("g")
          .data(fields())
          .enter().append("g");

        field.append("path");

        if (typeof self !== 'undefined' && self.frameElement) {
          d3.select(self.frameElement).style("height", height + "px");
        }

        // Human Time
        function tellTheTime() {
          try {
            if (typeof moment !== 'undefined') {
              var dayOfWeek = moment().format('dddd');
              var date = moment().format('ll');
              var hoursMinutesSeconds = moment().format('HH:mm');
              var dayOfWeekEl = document.getElementById('day-of-week');
              var dateEl = document.getElementById('date');
              var timeEl = document.getElementById('hours-minutes-seconds');
              if (dayOfWeekEl) dayOfWeekEl.innerHTML = dayOfWeek;
              if (dateEl) dateEl.innerHTML = date;
              if (timeEl) timeEl.innerHTML = hoursMinutesSeconds;
            }
          } catch(e) {}
        }

        var lastTimeUpdate = 0;

        function tick() {
          field = field.data(fields(), function(d) { return d.index; });

          // Handle enter: create new paths for new data elements
          var fieldEnter = field.enter().append("g");
          fieldEnter.append("path");

          // Handle exit: remove paths for elements that no longer exist
          field.exit().remove();

          // Handle update: update existing paths
          field.select("path")
            .attr("d", arc)
            .style("fill", function(d) { 
              if (d.index === 0.4) return COLORS.hourRing;
              if (d.index === 0.6) return COLORS.secondsIndicator;
              if (d.index === 0.65) return COLORS.secondArc;
              return COLORS.otherRings;
            })
            .style("opacity", function(d) {
              if (d.index === 0.6 && SHOW_SECONDS) {
                return SECONDS_OPACITY / 100; // Convert percentage to 0-1 range
              }
              if (d.index === 0.65 && SHOW_SECOND_ARC) {
                return SECOND_ARC_OPACITY / 100; // Convert percentage to 0-1 range
              }
              return 1; // Full opacity for all other rings
            });
          
          // Merge enter and update selections
          field = fieldEnter.merge(field);

          // Update time display only once per second
          var now = Date.now();
          if (now - lastTimeUpdate >= 1000) {
            tellTheTime();
            lastTimeUpdate = now;
          }
        }

        // Use setInterval for maximum compatibility
        // Update frequently for smooth continuous seconds movement
        setInterval(tick, 10); // Update every 10ms for very smooth animation
        
        // Initial render
        tick();
        }
        
        // Start initialization
        init();
      })();
    </script>
  </body>
</html>